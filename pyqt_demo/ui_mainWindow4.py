# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'ui_mainWindow4.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import array
import pandas as pd
import numpy as np
import scipy
import pyqtgraph as pg
import threading
import os
import time
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib import pyplot as plt
from pyqtgraph import PlotWidget
from functools import reduce
from kafka import KafkaConsumer
from PyQt5 import QtCore
from keras.models import load_model
from sklearn.preprocessing import MinMaxScaler
from scipy.ndimage import gaussian_filter1d
from scipy.signal import medfilt
from PyQt5 import QtCore, QtGui, QtWidgets
from scipy.integrate import simps  # 用于计算积分
from datetime import datetime


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1138, 752)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setObjectName("groupBox_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.groupBox_2)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.plotWidget = PlotWidget(self.groupBox_2)
        self.plotWidget.setObjectName("plotWidget")
        self.plotWidget.setTitle("Storm")
        self.verticalLayout_4.addWidget(self.plotWidget)
        self.plotWidget_2 = PlotWidget(self.groupBox_2)
        self.plotWidget_2.setObjectName("plotWidget_2")
        self.plotWidget_2.setTitle("Spannung")
        self.verticalLayout_4.addWidget(self.plotWidget_2)
        self.horizontalLayout_2.addLayout(self.verticalLayout_4)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.plotWidget_3 = PlotWidget(self.groupBox_2)
        self.plotWidget_3.setObjectName("plotWidget_3")
        self.plotWidget_3.setTitle("Zündfehler")
        self.verticalLayout_6.addWidget(self.plotWidget_3)
        self.plotWidget_4 = PlotWidget(self.groupBox_2)
        self.plotWidget_4.setObjectName("plotWidget_4")
        self.plotWidget_4.setTitle("Spritzern")
        self.verticalLayout_6.addWidget(self.plotWidget_4)
        self.horizontalLayout_2.addLayout(self.verticalLayout_6)
        self.horizontalLayout_2.setStretch(0, 2)
        self.horizontalLayout_2.setStretch(1, 1)
        self.horizontalLayout_3.addLayout(self.horizontalLayout_2)
        self.verticalLayout_8.addWidget(self.groupBox_2)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_9.addItem(spacerItem)
        self.pushButton_start = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_start.setObjectName("pushButton_start")
        self.horizontalLayout_9.addWidget(self.pushButton_start)
        self.pushButton_cancel = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_cancel.setObjectName("pushButton_cancel")
        self.horizontalLayout_9.addWidget(self.pushButton_cancel)
        self.horizontalLayout_9.setStretch(0, 9)
        self.horizontalLayout_9.setStretch(1, 1)
        self.horizontalLayout_9.setStretch(2, 1)
        self.verticalLayout_8.addLayout(self.horizontalLayout_9)
        self.horizontalLayout_10.addLayout(self.verticalLayout_8)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1138, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton_start.clicked.connect(self.run_signal)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "LSTM-based Anomaly Detection"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Signalverarbeitung"))
        self.pushButton_start.setText(_translate("MainWindow", "Start"))
        self.pushButton_cancel.setText(_translate("MainWindow", "Cancel"))

    @staticmethod
    def cal_integral(x, y):
        # 定义计算离散点积分的函数
        integrals = []
        for i in range(len(y)):  # 计算梯形的面积，由于是累加，所以是切片"i+1"
            integrals.append(scipy.integrate.trapz(y[:i + 1], x[:i + 1]))
        return integrals

    def run_signal(self):
        self.consumer_current = KafkaConsumer("Current", bootstrap_servers=["localhost:9092"],
                                              auto_offset_reset='latest',
                                              consumer_timeout_ms=6000)
        self.consumer_voltage = KafkaConsumer("Voltage", bootstrap_servers=["localhost:9092"],
                                              auto_offset_reset='latest',
                                              consumer_timeout_ms=6000)
        self.model_current = load_model('../LSTM/input/model/current_without_zundfehler.h5')
        self.model_voltage = load_model('../LSTM/input/model/merge_voltage.h5')
        self.model_only_cmt = load_model('../LSTM/input/model/merge_current_10.h5')

        self.length = 1500  # 横坐标长度
        self.ptr = 0
        self.signal_status_list = [0, 0, 0]
        self.record_frequenz = ['', '']
        self.record_time = []
        self.record_two_time = ['', '']
        self.flag = True
        self.data_frequenz_cmt, self.data_frequenz_pulse = [], []

        self.data_current = array.array('i')
        self.data_current = np.zeros(self.length).__array__('d')  # 把数组长度定下来
        self.data_voltage = array.array('i')
        self.data_voltage = np.zeros(self.length).__array__('d')  # 把数组长度定下来
        self.t = [''] * self.length  # 把时间数组长度定下来

        self.curve_current = self.plotWidget.plot(self.data_current, name="mode2")
        self.curve_voltage = self.plotWidget_2.plot(self.data_voltage, name="mode2")
        self.curve_zundfehler = self.plotWidget_3.plot(self.data_current, name="mode2")
        self.curve_spritzern = self.plotWidget_4.plot(self.data_voltage, name="mode2")

        self.timer_current = pg.QtCore.QTimer()  # 设定定时器
        self.timer_current.timeout.connect(self.update_data_current)  # 定时器信号绑定 update_data 函数
        self.timer_current.start(1)  # 1ms 刷新一次数据

        self.timer_voltage = pg.QtCore.QTimer()  # 设定定时器
        self.timer_voltage.timeout.connect(self.update_data_voltage)  # 定时器信号绑定 update_data 函数
        self.timer_voltage.start(1)  # 1ms 刷新一次数据

        self.timer_zundfehler = pg.QtCore.QTimer()  # 设定定时器
        self.timer_zundfehler.timeout.connect(self.anomaly_detection)  # 定时器信号绑定 update_data 函数
        self.timer_zundfehler.start(1)  # 1ms 刷新一次数据

        th1 = threading.Thread(target=self.get_data_current)
        th1.start()
        th2 = threading.Thread(target=self.get_data_voltage)
        th2.start()

    @staticmethod
    def data_split(sequence, n_timestamp):
        X, y = [], []
        for i in range(len(sequence)):
            end_ix = i + n_timestamp
            if end_ix > len(sequence) - 1:
                break
            seq_x, seq_y = sequence[i:end_ix], sequence[end_ix]
            X.append(seq_x)
            y.append(seq_y)
        return np.array(X), np.array(y)

    def zundfehler_detection_thread(self):
        ptr, t, threshold, length = self.ptr, self.t, 25, 200
        # 读取成series然后进行中值、高斯滤波，然后归一化
        ser = pd.Series(self.data_current[-length:])
        ser = medfilt(ser, 3)
        ser = gaussian_filter1d(ser, 1.2).reshape(-1, 1)

        sc = MinMaxScaler(feature_range=(0, 1))
        data_streaming_scaled = sc.fit_transform(ser)

        # 分割数据
        x, y = self.data_split(data_streaming_scaled, 10)
        x = x.reshape(x.shape[0], x.shape[1], 1)

        # 预测数据
        y_predicted = self.model_current.predict(x)
        # 'De-normalize' the data
        y_predicted_descaled = sc.inverse_transform(y_predicted)
        y_test_descaled = sc.inverse_transform(y)

        # 计算残差
        residual = y_test_descaled - y_predicted_descaled
        residual = np.squeeze(residual)
        idx = np.argmax(residual)
        # print("zundfehler: ", self.length + ptr - length + idx, t[self.length - length + idx], residual[idx])
        if residual[idx] > threshold and residual[idx] < 50:
            pos = self.length + ptr - length + idx
            zundfehler = np.squeeze(ser[idx:])
            self.curve_zundfehler.setData(zundfehler)
            self.curve_zundfehler.setPos(pos, 0)
            # print("[INFO] Zundfehler: ", pos, t[self.length - length + idx], residual[idx])

    def spritzern_detection_thread(self):
        ptr, t, threshold, length = self.ptr, self.t, 0.24, 160
        # 读取成series然后进行中值、高斯滤波，然后归一化
        ser = pd.Series(self.data_voltage[-length:])
        ser = medfilt(ser, 3)
        ser = gaussian_filter1d(ser, 1.2).reshape(-1, 1)

        sc = MinMaxScaler(feature_range=(0, 1))
        data_streaming_scaled = sc.fit_transform(ser)

        # 分割数据
        x, y = self.data_split(data_streaming_scaled, 5)
        x = x.reshape(x.shape[0], x.shape[1], 1)

        # 预测数据
        y_predicted = self.model_voltage.predict(x)
        # 'De-normalize' the data
        y_predicted_descaled = sc.inverse_transform(y_predicted)
        y_test_descaled = sc.inverse_transform(y)

        # 计算残差
        residual = y_test_descaled - y_predicted_descaled
        residual = np.squeeze(residual)
        idx = np.argmax(residual)
        # print("spritzern: ", self.length + ptr - length + idx, t[self.length - length + idx], residual[idx])
        if residual[idx] > threshold and residual[idx] < 1.5:
            pos = self.length + ptr - length + idx
            spritzern = np.squeeze(ser[idx:])
            self.curve_spritzern.setData(spritzern)
            self.curve_spritzern.setPos(pos, 0)
            # print("[INFO] Spritzern: ", pos, t[self.length - length + idx], residual[idx])

    def signal_status(self):
        ptr, t, threshold, length = self.ptr, self.t, 4, 100
        # 读取成series然后进行中值、高斯滤波，然后归一化
        ser = pd.Series(self.data_current[-length:])
        ser = medfilt(ser, 3)
        ser = gaussian_filter1d(ser, 1.2).reshape(-1, 1)

        sc = MinMaxScaler(feature_range=(0, 1))
        data_streaming_scaled = sc.fit_transform(ser)

        # 分割数据
        x, y = self.data_split(data_streaming_scaled, 10)
        x = x.reshape(x.shape[0], x.shape[1], 1)

        # 预测数据
        y_predicted = self.model_current.predict(x)
        # 'De-normalize' the data
        y_predicted_descaled = sc.inverse_transform(y_predicted)
        y_test_descaled = sc.inverse_transform(y)

        # 计算残差
        residual = y_test_descaled - y_predicted_descaled
        residual = np.squeeze(residual)
        idx = np.argmax(residual)
        pos = self.length + ptr - length + idx
        t_now = t[self.length - length + idx]
        # print("zundfehler: ", self.length + ptr - length + idx, t[self.length - length + idx], residual[idx])
        if residual[idx] < threshold or residual[idx] > 6.9:
            if self.signal_status_list[-1] != pos:
                self.signal_status_list[:-1] = self.signal_status_list[1:]
                self.signal_status_list[-1] = pos
            if self.signal_status_list[1] - self.signal_status_list[0] < 150 and self.signal_status_list[2] - self.signal_status_list[1] < 300:
                if self.flag is False:
                    self.record_time.append(t_now)
                    self.record_frequenz[:-1] = self.record_frequenz[1:]
                    self.record_frequenz[-1] = "c"
                    if self.record_frequenz[0] == "c" and self.record_frequenz[1] == "c":
                        self.flag = True
                        self.record_two_time[:-1] = self.record_two_time[1:]
                        self.record_two_time[-1] = self.record_time[0]
                        self.record_time = []
                        print("[INFO] CMT: ", pos, t_now, residual[idx])
                        if self.record_two_time[0] != '' and self.record_two_time[1] != '':
                            t1 = datetime.strptime(self.record_two_time[0], '%Y-%m-%d %H:%M:%S')
                            t2 = datetime.strptime(self.record_two_time[1], '%Y-%m-%d %H:%M:%S')
                            self.data_frequenz_cmt.append(1/(t2-t1).seconds)

        else:
            if self.flag is True:
                self.record_time.append(t_now)
                self.record_frequenz[:-1] = self.record_frequenz[1:]
                self.record_frequenz[-1] = "p"
                if self.record_frequenz[0] == "p" and self.record_frequenz[1] == "p":
                    self.flag = False
                    self.record_two_time[:-1] = self.record_two_time[1:]
                    self.record_two_time[-1] = self.record_time[0]
                    self.record_time = []
                    print("[INFO] Pulse: ", pos, t[self.length - length + idx], residual[idx])
                    if self.record_two_time[0] != '' and self.record_two_time[1] != '':
                        t1 = datetime.strptime(self.record_two_time[0], '%Y-%m-%d %H:%M:%S')
                        t2 = datetime.strptime(self.record_two_time[1], '%Y-%m-%d %H:%M:%S')
                        self.data_frequenz_pulse.append(1 / (t2 - t1).seconds)


    def anomaly_detection(self):
        if self.ptr % 100 == 0:
            th1 = threading.Thread(target=self.zundfehler_detection_thread)
            th1.start()
            th2 = threading.Thread(target=self.signal_status)
            th2.start()
        if self.ptr % 80 == 0:
            th3 = threading.Thread(target=self.spritzern_detection_thread)
            th3.start()

    def get_data_current(self):
        for msg in self.consumer_current:
            value_current = msg.value.decode('utf8').split('&')
            # 序号、时间、值
            self.ptr = int(value_current[0])

            if len(self.data_current) < self.length:
                self.data_current.append(float(value_current[2]))
                self.t.append(value_current[1])
            else:
                self.data_current[:-1] = self.data_current[1:]
                self.data_current[-1] = float(value_current[2])

                self.t[:-1] = self.t[1:]
                self.t[-1] = value_current[1]

    def get_data_voltage(self):
        for msg in self.consumer_voltage:
            value_voltage = msg.value.decode('utf8').split('&')

            if len(self.data_voltage) < self.length:
                self.data_voltage.append(float(value_voltage[-1]))
            else:
                self.data_voltage[:-1] = self.data_voltage[1:]
                self.data_voltage[-1] = float(value_voltage[-1])

    @staticmethod
    def calc_energy(lt):
        return reduce(lambda x, y: x + y, map(lambda x: x ** 2, lt))

    def find_extreme_value(self, data, flag):
        if self.ptr % 200 == 0:
            max_idx, min_idx = np.argmax(data), np.argmin(data)
            max_value, min_value = data[max_idx], data[min_idx]
            energy = self.calc_energy(data)
            print('[INFO] time(%s): %-8s - %s - energy: %d' % (flag, self.t[-1], self.number[-1], energy))
            print('[INFO] \tmin_time: %-6s - min_value: %-8.3f  max_time:%-6s - max_value: %.3f'
                  % (self.number[min_idx], min_value, self.number[max_idx], max_value))
            print('=' * 70)

    def update_data_voltage(self):
        """ 数据左移 """
        if self.data_voltage is not None:
            self.curve_voltage.setData(self.data_voltage)  # 数据填充到绘制曲线中
            # self.find_extreme_value(self.data_voltage, flag='Voltage')
            self.curve_voltage.setPos(self.ptr, 0)  # 重新设定 x 相关的坐标原点

    def update_data_current(self):
        """ 数据左移 """
        if self.data_current is not None:
            self.curve_current.setData(self.data_current)  # 数据填充到绘制曲线中
            # self.ptr = self.value_current[0]  # x 轴记录点
            # self.find_extreme_value(self.data_current, flag='Current')
            self.curve_current.setPos(self.ptr, 0)  # 重新设定 x 相关的坐标原点


